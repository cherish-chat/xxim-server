// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: msg.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on MsgMQBody with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MsgMQBody) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MsgMQBody with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MsgMQBodyMultiError, or nil
// if none found.
func (m *MsgMQBody) ValidateAll() error {
	return m.validate(true)
}

func (m *MsgMQBody) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Event

	// no validation rules for Data

	if len(errors) > 0 {
		return MsgMQBodyMultiError(errors)
	}

	return nil
}

// MsgMQBodyMultiError is an error wrapping multiple validation errors returned
// by MsgMQBody.ValidateAll() if the designated constraints aren't met.
type MsgMQBodyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MsgMQBodyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MsgMQBodyMultiError) AllErrors() []error { return m }

// MsgMQBodyValidationError is the validation error returned by
// MsgMQBody.Validate if the designated constraints aren't met.
type MsgMQBodyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MsgMQBodyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MsgMQBodyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MsgMQBodyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MsgMQBodyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MsgMQBodyValidationError) ErrorName() string { return "MsgMQBodyValidationError" }

// Error satisfies the builtin error interface
func (e MsgMQBodyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMsgMQBody.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MsgMQBodyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MsgMQBodyValidationError{}

// Validate checks the field values on MsgData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MsgData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MsgData with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MsgDataMultiError, or nil if none found.
func (m *MsgData) ValidateAll() error {
	return m.validate(true)
}

func (m *MsgData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClientMsgId

	// no validation rules for ServerMsgId

	// no validation rules for ClientTime

	// no validation rules for ServerTime

	// no validation rules for SenderId

	// no validation rules for SenderInfo

	// no validation rules for ConvId

	// no validation rules for ContentType

	// no validation rules for Content

	// no validation rules for Seq

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MsgDataValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MsgDataValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MsgDataValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOfflinePush()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MsgDataValidationError{
					field:  "OfflinePush",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MsgDataValidationError{
					field:  "OfflinePush",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOfflinePush()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MsgDataValidationError{
				field:  "OfflinePush",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Ext

	if len(errors) > 0 {
		return MsgDataMultiError(errors)
	}

	return nil
}

// MsgDataMultiError is an error wrapping multiple validation errors returned
// by MsgData.ValidateAll() if the designated constraints aren't met.
type MsgDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MsgDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MsgDataMultiError) AllErrors() []error { return m }

// MsgDataValidationError is the validation error returned by MsgData.Validate
// if the designated constraints aren't met.
type MsgDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MsgDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MsgDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MsgDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MsgDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MsgDataValidationError) ErrorName() string { return "MsgDataValidationError" }

// Error satisfies the builtin error interface
func (e MsgDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMsgData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MsgDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MsgDataValidationError{}

// Validate checks the field values on MsgDataList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MsgDataList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MsgDataList with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MsgDataListMultiError, or
// nil if none found.
func (m *MsgDataList) ValidateAll() error {
	return m.validate(true)
}

func (m *MsgDataList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMsgDataList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MsgDataListValidationError{
						field:  fmt.Sprintf("MsgDataList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MsgDataListValidationError{
						field:  fmt.Sprintf("MsgDataList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MsgDataListValidationError{
					field:  fmt.Sprintf("MsgDataList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MsgDataListMultiError(errors)
	}

	return nil
}

// MsgDataListMultiError is an error wrapping multiple validation errors
// returned by MsgDataList.ValidateAll() if the designated constraints aren't met.
type MsgDataListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MsgDataListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MsgDataListMultiError) AllErrors() []error { return m }

// MsgDataListValidationError is the validation error returned by
// MsgDataList.Validate if the designated constraints aren't met.
type MsgDataListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MsgDataListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MsgDataListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MsgDataListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MsgDataListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MsgDataListValidationError) ErrorName() string { return "MsgDataListValidationError" }

// Error satisfies the builtin error interface
func (e MsgDataListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMsgDataList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MsgDataListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MsgDataListValidationError{}

// Validate checks the field values on SendMsgListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SendMsgListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendMsgListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SendMsgListReqMultiError,
// or nil if none found.
func (m *SendMsgListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SendMsgListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendMsgListReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendMsgListReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendMsgListReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetMsgDataList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SendMsgListReqValidationError{
						field:  fmt.Sprintf("MsgDataList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SendMsgListReqValidationError{
						field:  fmt.Sprintf("MsgDataList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SendMsgListReqValidationError{
					field:  fmt.Sprintf("MsgDataList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.DeliverAfter != nil {
		// no validation rules for DeliverAfter
	}

	if len(errors) > 0 {
		return SendMsgListReqMultiError(errors)
	}

	return nil
}

// SendMsgListReqMultiError is an error wrapping multiple validation errors
// returned by SendMsgListReq.ValidateAll() if the designated constraints
// aren't met.
type SendMsgListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendMsgListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendMsgListReqMultiError) AllErrors() []error { return m }

// SendMsgListReqValidationError is the validation error returned by
// SendMsgListReq.Validate if the designated constraints aren't met.
type SendMsgListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendMsgListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendMsgListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendMsgListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendMsgListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendMsgListReqValidationError) ErrorName() string { return "SendMsgListReqValidationError" }

// Error satisfies the builtin error interface
func (e SendMsgListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendMsgListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendMsgListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendMsgListReqValidationError{}

// Validate checks the field values on SendMsgListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SendMsgListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendMsgListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendMsgListRespMultiError, or nil if none found.
func (m *SendMsgListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SendMsgListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendMsgListRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendMsgListRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendMsgListRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SendMsgListRespMultiError(errors)
	}

	return nil
}

// SendMsgListRespMultiError is an error wrapping multiple validation errors
// returned by SendMsgListResp.ValidateAll() if the designated constraints
// aren't met.
type SendMsgListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendMsgListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendMsgListRespMultiError) AllErrors() []error { return m }

// SendMsgListRespValidationError is the validation error returned by
// SendMsgListResp.Validate if the designated constraints aren't met.
type SendMsgListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendMsgListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendMsgListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendMsgListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendMsgListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendMsgListRespValidationError) ErrorName() string { return "SendMsgListRespValidationError" }

// Error satisfies the builtin error interface
func (e SendMsgListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendMsgListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendMsgListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendMsgListRespValidationError{}

// Validate checks the field values on PushMsgListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PushMsgListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PushMsgListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PushMsgListReqMultiError,
// or nil if none found.
func (m *PushMsgListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PushMsgListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMsgDataList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PushMsgListReqValidationError{
						field:  fmt.Sprintf("MsgDataList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PushMsgListReqValidationError{
						field:  fmt.Sprintf("MsgDataList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PushMsgListReqValidationError{
					field:  fmt.Sprintf("MsgDataList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PushMsgListReqMultiError(errors)
	}

	return nil
}

// PushMsgListReqMultiError is an error wrapping multiple validation errors
// returned by PushMsgListReq.ValidateAll() if the designated constraints
// aren't met.
type PushMsgListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PushMsgListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PushMsgListReqMultiError) AllErrors() []error { return m }

// PushMsgListReqValidationError is the validation error returned by
// PushMsgListReq.Validate if the designated constraints aren't met.
type PushMsgListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PushMsgListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PushMsgListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PushMsgListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PushMsgListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PushMsgListReqValidationError) ErrorName() string { return "PushMsgListReqValidationError" }

// Error satisfies the builtin error interface
func (e PushMsgListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPushMsgListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PushMsgListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PushMsgListReqValidationError{}

// Validate checks the field values on BatchGetMsgListByConvIdReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchGetMsgListByConvIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchGetMsgListByConvIdReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchGetMsgListByConvIdReqMultiError, or nil if none found.
func (m *BatchGetMsgListByConvIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchGetMsgListByConvIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchGetMsgListByConvIdReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchGetMsgListByConvIdReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchGetMsgListByConvIdReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchGetMsgListByConvIdReqValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchGetMsgListByConvIdReqValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchGetMsgListByConvIdReqValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Push

	if len(errors) > 0 {
		return BatchGetMsgListByConvIdReqMultiError(errors)
	}

	return nil
}

// BatchGetMsgListByConvIdReqMultiError is an error wrapping multiple
// validation errors returned by BatchGetMsgListByConvIdReq.ValidateAll() if
// the designated constraints aren't met.
type BatchGetMsgListByConvIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetMsgListByConvIdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetMsgListByConvIdReqMultiError) AllErrors() []error { return m }

// BatchGetMsgListByConvIdReqValidationError is the validation error returned
// by BatchGetMsgListByConvIdReq.Validate if the designated constraints aren't met.
type BatchGetMsgListByConvIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetMsgListByConvIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetMsgListByConvIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetMsgListByConvIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetMsgListByConvIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetMsgListByConvIdReqValidationError) ErrorName() string {
	return "BatchGetMsgListByConvIdReqValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetMsgListByConvIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetMsgListByConvIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetMsgListByConvIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetMsgListByConvIdReqValidationError{}

// Validate checks the field values on GetMsgListResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetMsgListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMsgListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetMsgListRespMultiError,
// or nil if none found.
func (m *GetMsgListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMsgListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMsgListRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMsgListRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMsgListRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetMsgDataList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetMsgListRespValidationError{
						field:  fmt.Sprintf("MsgDataList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetMsgListRespValidationError{
						field:  fmt.Sprintf("MsgDataList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetMsgListRespValidationError{
					field:  fmt.Sprintf("MsgDataList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetMsgListRespMultiError(errors)
	}

	return nil
}

// GetMsgListRespMultiError is an error wrapping multiple validation errors
// returned by GetMsgListResp.ValidateAll() if the designated constraints
// aren't met.
type GetMsgListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMsgListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMsgListRespMultiError) AllErrors() []error { return m }

// GetMsgListRespValidationError is the validation error returned by
// GetMsgListResp.Validate if the designated constraints aren't met.
type GetMsgListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMsgListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMsgListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMsgListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMsgListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMsgListRespValidationError) ErrorName() string { return "GetMsgListRespValidationError" }

// Error satisfies the builtin error interface
func (e GetMsgListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMsgListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMsgListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMsgListRespValidationError{}

// Validate checks the field values on GetMsgByIdReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetMsgByIdReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMsgByIdReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetMsgByIdReqMultiError, or
// nil if none found.
func (m *GetMsgByIdReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMsgByIdReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMsgByIdReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMsgByIdReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMsgByIdReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Push

	if m.ServerMsgId != nil {
		// no validation rules for ServerMsgId
	}

	if m.ClientMsgId != nil {
		// no validation rules for ClientMsgId
	}

	if len(errors) > 0 {
		return GetMsgByIdReqMultiError(errors)
	}

	return nil
}

// GetMsgByIdReqMultiError is an error wrapping multiple validation errors
// returned by GetMsgByIdReq.ValidateAll() if the designated constraints
// aren't met.
type GetMsgByIdReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMsgByIdReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMsgByIdReqMultiError) AllErrors() []error { return m }

// GetMsgByIdReqValidationError is the validation error returned by
// GetMsgByIdReq.Validate if the designated constraints aren't met.
type GetMsgByIdReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMsgByIdReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMsgByIdReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMsgByIdReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMsgByIdReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMsgByIdReqValidationError) ErrorName() string { return "GetMsgByIdReqValidationError" }

// Error satisfies the builtin error interface
func (e GetMsgByIdReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMsgByIdReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMsgByIdReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMsgByIdReqValidationError{}

// Validate checks the field values on GetMsgByIdResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetMsgByIdResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMsgByIdResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetMsgByIdRespMultiError,
// or nil if none found.
func (m *GetMsgByIdResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMsgByIdResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMsgByIdRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMsgByIdRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMsgByIdRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMsgData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMsgByIdRespValidationError{
					field:  "MsgData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMsgByIdRespValidationError{
					field:  "MsgData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMsgData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMsgByIdRespValidationError{
				field:  "MsgData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetMsgByIdRespMultiError(errors)
	}

	return nil
}

// GetMsgByIdRespMultiError is an error wrapping multiple validation errors
// returned by GetMsgByIdResp.ValidateAll() if the designated constraints
// aren't met.
type GetMsgByIdRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMsgByIdRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMsgByIdRespMultiError) AllErrors() []error { return m }

// GetMsgByIdRespValidationError is the validation error returned by
// GetMsgByIdResp.Validate if the designated constraints aren't met.
type GetMsgByIdRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMsgByIdRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMsgByIdRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMsgByIdRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMsgByIdRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMsgByIdRespValidationError) ErrorName() string { return "GetMsgByIdRespValidationError" }

// Error satisfies the builtin error interface
func (e GetMsgByIdRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMsgByIdResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMsgByIdRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMsgByIdRespValidationError{}

// Validate checks the field values on BatchSetMinSeqReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BatchSetMinSeqReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchSetMinSeqReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchSetMinSeqReqMultiError, or nil if none found.
func (m *BatchSetMinSeqReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchSetMinSeqReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchSetMinSeqReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchSetMinSeqReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchSetMinSeqReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ConvId

	// no validation rules for MinSeq

	if len(errors) > 0 {
		return BatchSetMinSeqReqMultiError(errors)
	}

	return nil
}

// BatchSetMinSeqReqMultiError is an error wrapping multiple validation errors
// returned by BatchSetMinSeqReq.ValidateAll() if the designated constraints
// aren't met.
type BatchSetMinSeqReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchSetMinSeqReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchSetMinSeqReqMultiError) AllErrors() []error { return m }

// BatchSetMinSeqReqValidationError is the validation error returned by
// BatchSetMinSeqReq.Validate if the designated constraints aren't met.
type BatchSetMinSeqReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchSetMinSeqReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchSetMinSeqReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchSetMinSeqReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchSetMinSeqReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchSetMinSeqReqValidationError) ErrorName() string {
	return "BatchSetMinSeqReqValidationError"
}

// Error satisfies the builtin error interface
func (e BatchSetMinSeqReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchSetMinSeqReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchSetMinSeqReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchSetMinSeqReqValidationError{}

// Validate checks the field values on BatchSetMinSeqResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchSetMinSeqResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchSetMinSeqResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchSetMinSeqRespMultiError, or nil if none found.
func (m *BatchSetMinSeqResp) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchSetMinSeqResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchSetMinSeqRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchSetMinSeqRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchSetMinSeqRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BatchSetMinSeqRespMultiError(errors)
	}

	return nil
}

// BatchSetMinSeqRespMultiError is an error wrapping multiple validation errors
// returned by BatchSetMinSeqResp.ValidateAll() if the designated constraints
// aren't met.
type BatchSetMinSeqRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchSetMinSeqRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchSetMinSeqRespMultiError) AllErrors() []error { return m }

// BatchSetMinSeqRespValidationError is the validation error returned by
// BatchSetMinSeqResp.Validate if the designated constraints aren't met.
type BatchSetMinSeqRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchSetMinSeqRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchSetMinSeqRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchSetMinSeqRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchSetMinSeqRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchSetMinSeqRespValidationError) ErrorName() string {
	return "BatchSetMinSeqRespValidationError"
}

// Error satisfies the builtin error interface
func (e BatchSetMinSeqRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchSetMinSeqResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchSetMinSeqRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchSetMinSeqRespValidationError{}

// Validate checks the field values on BatchGetConvSeqReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchGetConvSeqReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchGetConvSeqReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchGetConvSeqReqMultiError, or nil if none found.
func (m *BatchGetConvSeqReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchGetConvSeqReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchGetConvSeqReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchGetConvSeqReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchGetConvSeqReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BatchGetConvSeqReqMultiError(errors)
	}

	return nil
}

// BatchGetConvSeqReqMultiError is an error wrapping multiple validation errors
// returned by BatchGetConvSeqReq.ValidateAll() if the designated constraints
// aren't met.
type BatchGetConvSeqReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetConvSeqReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetConvSeqReqMultiError) AllErrors() []error { return m }

// BatchGetConvSeqReqValidationError is the validation error returned by
// BatchGetConvSeqReq.Validate if the designated constraints aren't met.
type BatchGetConvSeqReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetConvSeqReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetConvSeqReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetConvSeqReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetConvSeqReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetConvSeqReqValidationError) ErrorName() string {
	return "BatchGetConvSeqReqValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetConvSeqReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetConvSeqReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetConvSeqReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetConvSeqReqValidationError{}

// Validate checks the field values on BatchGetConvSeqResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchGetConvSeqResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchGetConvSeqResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchGetConvSeqRespMultiError, or nil if none found.
func (m *BatchGetConvSeqResp) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchGetConvSeqResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchGetConvSeqRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchGetConvSeqRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchGetConvSeqRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetConvSeqMap()))
		i := 0
		for key := range m.GetConvSeqMap() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetConvSeqMap()[key]
			_ = val

			// no validation rules for ConvSeqMap[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, BatchGetConvSeqRespValidationError{
							field:  fmt.Sprintf("ConvSeqMap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, BatchGetConvSeqRespValidationError{
							field:  fmt.Sprintf("ConvSeqMap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return BatchGetConvSeqRespValidationError{
						field:  fmt.Sprintf("ConvSeqMap[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return BatchGetConvSeqRespMultiError(errors)
	}

	return nil
}

// BatchGetConvSeqRespMultiError is an error wrapping multiple validation
// errors returned by BatchGetConvSeqResp.ValidateAll() if the designated
// constraints aren't met.
type BatchGetConvSeqRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetConvSeqRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetConvSeqRespMultiError) AllErrors() []error { return m }

// BatchGetConvSeqRespValidationError is the validation error returned by
// BatchGetConvSeqResp.Validate if the designated constraints aren't met.
type BatchGetConvSeqRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetConvSeqRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetConvSeqRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetConvSeqRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetConvSeqRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetConvSeqRespValidationError) ErrorName() string {
	return "BatchGetConvSeqRespValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetConvSeqRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetConvSeqResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetConvSeqRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetConvSeqRespValidationError{}

// Validate checks the field values on GetConvSubscribersReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConvSubscribersReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConvSubscribersReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConvSubscribersReqMultiError, or nil if none found.
func (m *GetConvSubscribersReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConvSubscribersReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConvSubscribersReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConvSubscribersReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConvSubscribersReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ConvId

	if m.LastActiveTime != nil {
		// no validation rules for LastActiveTime
	}

	if len(errors) > 0 {
		return GetConvSubscribersReqMultiError(errors)
	}

	return nil
}

// GetConvSubscribersReqMultiError is an error wrapping multiple validation
// errors returned by GetConvSubscribersReq.ValidateAll() if the designated
// constraints aren't met.
type GetConvSubscribersReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConvSubscribersReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConvSubscribersReqMultiError) AllErrors() []error { return m }

// GetConvSubscribersReqValidationError is the validation error returned by
// GetConvSubscribersReq.Validate if the designated constraints aren't met.
type GetConvSubscribersReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConvSubscribersReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConvSubscribersReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConvSubscribersReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConvSubscribersReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConvSubscribersReqValidationError) ErrorName() string {
	return "GetConvSubscribersReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetConvSubscribersReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConvSubscribersReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConvSubscribersReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConvSubscribersReqValidationError{}

// Validate checks the field values on GetConvSubscribersResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConvSubscribersResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConvSubscribersResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConvSubscribersRespMultiError, or nil if none found.
func (m *GetConvSubscribersResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConvSubscribersResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConvSubscribersRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConvSubscribersRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConvSubscribersRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetPodIpMap()))
		i := 0
		for key := range m.GetPodIpMap() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPodIpMap()[key]
			_ = val

			// no validation rules for PodIpMap[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetConvSubscribersRespValidationError{
							field:  fmt.Sprintf("PodIpMap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetConvSubscribersRespValidationError{
							field:  fmt.Sprintf("PodIpMap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetConvSubscribersRespValidationError{
						field:  fmt.Sprintf("PodIpMap[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return GetConvSubscribersRespMultiError(errors)
	}

	return nil
}

// GetConvSubscribersRespMultiError is an error wrapping multiple validation
// errors returned by GetConvSubscribersResp.ValidateAll() if the designated
// constraints aren't met.
type GetConvSubscribersRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConvSubscribersRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConvSubscribersRespMultiError) AllErrors() []error { return m }

// GetConvSubscribersRespValidationError is the validation error returned by
// GetConvSubscribersResp.Validate if the designated constraints aren't met.
type GetConvSubscribersRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConvSubscribersRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConvSubscribersRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConvSubscribersRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConvSubscribersRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConvSubscribersRespValidationError) ErrorName() string {
	return "GetConvSubscribersRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetConvSubscribersRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConvSubscribersResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConvSubscribersRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConvSubscribersRespValidationError{}

// Validate checks the field values on OfflinePushMsgReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OfflinePushMsgReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OfflinePushMsgReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OfflinePushMsgReqMultiError, or nil if none found.
func (m *OfflinePushMsgReq) ValidateAll() error {
	return m.validate(true)
}

func (m *OfflinePushMsgReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OfflinePushMsgReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OfflinePushMsgReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OfflinePushMsgReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Title

	// no validation rules for Content

	// no validation rules for Payload

	// no validation rules for UniqueId

	if len(errors) > 0 {
		return OfflinePushMsgReqMultiError(errors)
	}

	return nil
}

// OfflinePushMsgReqMultiError is an error wrapping multiple validation errors
// returned by OfflinePushMsgReq.ValidateAll() if the designated constraints
// aren't met.
type OfflinePushMsgReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OfflinePushMsgReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OfflinePushMsgReqMultiError) AllErrors() []error { return m }

// OfflinePushMsgReqValidationError is the validation error returned by
// OfflinePushMsgReq.Validate if the designated constraints aren't met.
type OfflinePushMsgReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OfflinePushMsgReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OfflinePushMsgReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OfflinePushMsgReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OfflinePushMsgReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OfflinePushMsgReqValidationError) ErrorName() string {
	return "OfflinePushMsgReqValidationError"
}

// Error satisfies the builtin error interface
func (e OfflinePushMsgReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOfflinePushMsgReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OfflinePushMsgReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OfflinePushMsgReqValidationError{}

// Validate checks the field values on OfflinePushMsgResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OfflinePushMsgResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OfflinePushMsgResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OfflinePushMsgRespMultiError, or nil if none found.
func (m *OfflinePushMsgResp) ValidateAll() error {
	return m.validate(true)
}

func (m *OfflinePushMsgResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OfflinePushMsgRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OfflinePushMsgRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OfflinePushMsgRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OfflinePushMsgRespMultiError(errors)
	}

	return nil
}

// OfflinePushMsgRespMultiError is an error wrapping multiple validation errors
// returned by OfflinePushMsgResp.ValidateAll() if the designated constraints
// aren't met.
type OfflinePushMsgRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OfflinePushMsgRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OfflinePushMsgRespMultiError) AllErrors() []error { return m }

// OfflinePushMsgRespValidationError is the validation error returned by
// OfflinePushMsgResp.Validate if the designated constraints aren't met.
type OfflinePushMsgRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OfflinePushMsgRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OfflinePushMsgRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OfflinePushMsgRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OfflinePushMsgRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OfflinePushMsgRespValidationError) ErrorName() string {
	return "OfflinePushMsgRespValidationError"
}

// Error satisfies the builtin error interface
func (e OfflinePushMsgRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOfflinePushMsgResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OfflinePushMsgRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OfflinePushMsgRespValidationError{}

// Validate checks the field values on GetConvOnlineCountReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConvOnlineCountReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConvOnlineCountReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConvOnlineCountReqMultiError, or nil if none found.
func (m *GetConvOnlineCountReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConvOnlineCountReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConvOnlineCountReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConvOnlineCountReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConvOnlineCountReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ConvId

	if len(errors) > 0 {
		return GetConvOnlineCountReqMultiError(errors)
	}

	return nil
}

// GetConvOnlineCountReqMultiError is an error wrapping multiple validation
// errors returned by GetConvOnlineCountReq.ValidateAll() if the designated
// constraints aren't met.
type GetConvOnlineCountReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConvOnlineCountReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConvOnlineCountReqMultiError) AllErrors() []error { return m }

// GetConvOnlineCountReqValidationError is the validation error returned by
// GetConvOnlineCountReq.Validate if the designated constraints aren't met.
type GetConvOnlineCountReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConvOnlineCountReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConvOnlineCountReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConvOnlineCountReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConvOnlineCountReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConvOnlineCountReqValidationError) ErrorName() string {
	return "GetConvOnlineCountReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetConvOnlineCountReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConvOnlineCountReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConvOnlineCountReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConvOnlineCountReqValidationError{}

// Validate checks the field values on GetConvOnlineCountResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConvOnlineCountResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConvOnlineCountResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConvOnlineCountRespMultiError, or nil if none found.
func (m *GetConvOnlineCountResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConvOnlineCountResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConvOnlineCountRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConvOnlineCountRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConvOnlineCountRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for User

	// no validation rules for Device

	if len(errors) > 0 {
		return GetConvOnlineCountRespMultiError(errors)
	}

	return nil
}

// GetConvOnlineCountRespMultiError is an error wrapping multiple validation
// errors returned by GetConvOnlineCountResp.ValidateAll() if the designated
// constraints aren't met.
type GetConvOnlineCountRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConvOnlineCountRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConvOnlineCountRespMultiError) AllErrors() []error { return m }

// GetConvOnlineCountRespValidationError is the validation error returned by
// GetConvOnlineCountResp.Validate if the designated constraints aren't met.
type GetConvOnlineCountRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConvOnlineCountRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConvOnlineCountRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConvOnlineCountRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConvOnlineCountRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConvOnlineCountRespValidationError) ErrorName() string {
	return "GetConvOnlineCountRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetConvOnlineCountRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConvOnlineCountResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConvOnlineCountRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConvOnlineCountRespValidationError{}

// Validate checks the field values on MsgData_OfflinePush with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MsgData_OfflinePush) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MsgData_OfflinePush with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MsgData_OfflinePushMultiError, or nil if none found.
func (m *MsgData_OfflinePush) ValidateAll() error {
	return m.validate(true)
}

func (m *MsgData_OfflinePush) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for Content

	// no validation rules for Payload

	if len(errors) > 0 {
		return MsgData_OfflinePushMultiError(errors)
	}

	return nil
}

// MsgData_OfflinePushMultiError is an error wrapping multiple validation
// errors returned by MsgData_OfflinePush.ValidateAll() if the designated
// constraints aren't met.
type MsgData_OfflinePushMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MsgData_OfflinePushMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MsgData_OfflinePushMultiError) AllErrors() []error { return m }

// MsgData_OfflinePushValidationError is the validation error returned by
// MsgData_OfflinePush.Validate if the designated constraints aren't met.
type MsgData_OfflinePushValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MsgData_OfflinePushValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MsgData_OfflinePushValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MsgData_OfflinePushValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MsgData_OfflinePushValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MsgData_OfflinePushValidationError) ErrorName() string {
	return "MsgData_OfflinePushValidationError"
}

// Error satisfies the builtin error interface
func (e MsgData_OfflinePushValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMsgData_OfflinePush.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MsgData_OfflinePushValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MsgData_OfflinePushValidationError{}

// Validate checks the field values on MsgData_Options with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MsgData_Options) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MsgData_Options with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MsgData_OptionsMultiError, or nil if none found.
func (m *MsgData_Options) ValidateAll() error {
	return m.validate(true)
}

func (m *MsgData_Options) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StorageForServer

	// no validation rules for StorageForClient

	// no validation rules for NeedDecrypt

	// no validation rules for OfflinePush

	// no validation rules for UpdateConvMsg

	// no validation rules for UpdateUnreadCount

	if len(errors) > 0 {
		return MsgData_OptionsMultiError(errors)
	}

	return nil
}

// MsgData_OptionsMultiError is an error wrapping multiple validation errors
// returned by MsgData_Options.ValidateAll() if the designated constraints
// aren't met.
type MsgData_OptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MsgData_OptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MsgData_OptionsMultiError) AllErrors() []error { return m }

// MsgData_OptionsValidationError is the validation error returned by
// MsgData_Options.Validate if the designated constraints aren't met.
type MsgData_OptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MsgData_OptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MsgData_OptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MsgData_OptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MsgData_OptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MsgData_OptionsValidationError) ErrorName() string { return "MsgData_OptionsValidationError" }

// Error satisfies the builtin error interface
func (e MsgData_OptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMsgData_Options.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MsgData_OptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MsgData_OptionsValidationError{}

// Validate checks the field values on BatchGetMsgListByConvIdReq_Item with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchGetMsgListByConvIdReq_Item) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchGetMsgListByConvIdReq_Item with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BatchGetMsgListByConvIdReq_ItemMultiError, or nil if none found.
func (m *BatchGetMsgListByConvIdReq_Item) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchGetMsgListByConvIdReq_Item) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConvId

	if len(errors) > 0 {
		return BatchGetMsgListByConvIdReq_ItemMultiError(errors)
	}

	return nil
}

// BatchGetMsgListByConvIdReq_ItemMultiError is an error wrapping multiple
// validation errors returned by BatchGetMsgListByConvIdReq_Item.ValidateAll()
// if the designated constraints aren't met.
type BatchGetMsgListByConvIdReq_ItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetMsgListByConvIdReq_ItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetMsgListByConvIdReq_ItemMultiError) AllErrors() []error { return m }

// BatchGetMsgListByConvIdReq_ItemValidationError is the validation error
// returned by BatchGetMsgListByConvIdReq_Item.Validate if the designated
// constraints aren't met.
type BatchGetMsgListByConvIdReq_ItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetMsgListByConvIdReq_ItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetMsgListByConvIdReq_ItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetMsgListByConvIdReq_ItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetMsgListByConvIdReq_ItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetMsgListByConvIdReq_ItemValidationError) ErrorName() string {
	return "BatchGetMsgListByConvIdReq_ItemValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetMsgListByConvIdReq_ItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetMsgListByConvIdReq_Item.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetMsgListByConvIdReq_ItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetMsgListByConvIdReq_ItemValidationError{}

// Validate checks the field values on BatchGetConvSeqResp_ConvSeq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchGetConvSeqResp_ConvSeq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchGetConvSeqResp_ConvSeq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchGetConvSeqResp_ConvSeqMultiError, or nil if none found.
func (m *BatchGetConvSeqResp_ConvSeq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchGetConvSeqResp_ConvSeq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConvId

	// no validation rules for MinSeq

	// no validation rules for MaxSeq

	// no validation rules for UpdateTime

	if len(errors) > 0 {
		return BatchGetConvSeqResp_ConvSeqMultiError(errors)
	}

	return nil
}

// BatchGetConvSeqResp_ConvSeqMultiError is an error wrapping multiple
// validation errors returned by BatchGetConvSeqResp_ConvSeq.ValidateAll() if
// the designated constraints aren't met.
type BatchGetConvSeqResp_ConvSeqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetConvSeqResp_ConvSeqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetConvSeqResp_ConvSeqMultiError) AllErrors() []error { return m }

// BatchGetConvSeqResp_ConvSeqValidationError is the validation error returned
// by BatchGetConvSeqResp_ConvSeq.Validate if the designated constraints
// aren't met.
type BatchGetConvSeqResp_ConvSeqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetConvSeqResp_ConvSeqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetConvSeqResp_ConvSeqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetConvSeqResp_ConvSeqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetConvSeqResp_ConvSeqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetConvSeqResp_ConvSeqValidationError) ErrorName() string {
	return "BatchGetConvSeqResp_ConvSeqValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetConvSeqResp_ConvSeqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetConvSeqResp_ConvSeq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetConvSeqResp_ConvSeqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetConvSeqResp_ConvSeqValidationError{}

// Validate checks the field values on GetConvSubscribersRespUidList with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConvSubscribersRespUidList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConvSubscribersRespUidList with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetConvSubscribersRespUidListMultiError, or nil if none found.
func (m *GetConvSubscribersRespUidList) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConvSubscribersRespUidList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PodIp

	if len(errors) > 0 {
		return GetConvSubscribersRespUidListMultiError(errors)
	}

	return nil
}

// GetConvSubscribersRespUidListMultiError is an error wrapping multiple
// validation errors returned by GetConvSubscribersRespUidList.ValidateAll()
// if the designated constraints aren't met.
type GetConvSubscribersRespUidListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConvSubscribersRespUidListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConvSubscribersRespUidListMultiError) AllErrors() []error { return m }

// GetConvSubscribersRespUidListValidationError is the validation error
// returned by GetConvSubscribersRespUidList.Validate if the designated
// constraints aren't met.
type GetConvSubscribersRespUidListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConvSubscribersRespUidListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConvSubscribersRespUidListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConvSubscribersRespUidListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConvSubscribersRespUidListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConvSubscribersRespUidListValidationError) ErrorName() string {
	return "GetConvSubscribersRespUidListValidationError"
}

// Error satisfies the builtin error interface
func (e GetConvSubscribersRespUidListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConvSubscribersRespUidList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConvSubscribersRespUidListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConvSubscribersRespUidListValidationError{}
