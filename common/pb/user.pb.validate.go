// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: user.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on BirthdayInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BirthdayInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BirthdayInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BirthdayInfoMultiError, or
// nil if none found.
func (m *BirthdayInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BirthdayInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Year

	// no validation rules for Month

	// no validation rules for Day

	// no validation rules for Age

	// no validation rules for Constellation

	if len(errors) > 0 {
		return BirthdayInfoMultiError(errors)
	}

	return nil
}

// BirthdayInfoMultiError is an error wrapping multiple validation errors
// returned by BirthdayInfo.ValidateAll() if the designated constraints aren't met.
type BirthdayInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BirthdayInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BirthdayInfoMultiError) AllErrors() []error { return m }

// BirthdayInfoValidationError is the validation error returned by
// BirthdayInfo.Validate if the designated constraints aren't met.
type BirthdayInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BirthdayInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BirthdayInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BirthdayInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BirthdayInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BirthdayInfoValidationError) ErrorName() string { return "BirthdayInfoValidationError" }

// Error satisfies the builtin error interface
func (e BirthdayInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBirthdayInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BirthdayInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BirthdayInfoValidationError{}

// Validate checks the field values on LevelInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LevelInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LevelInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LevelInfoMultiError, or nil
// if none found.
func (m *LevelInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *LevelInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Level

	// no validation rules for Exp

	// no validation rules for NextLevelExp

	if len(errors) > 0 {
		return LevelInfoMultiError(errors)
	}

	return nil
}

// LevelInfoMultiError is an error wrapping multiple validation errors returned
// by LevelInfo.ValidateAll() if the designated constraints aren't met.
type LevelInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LevelInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LevelInfoMultiError) AllErrors() []error { return m }

// LevelInfoValidationError is the validation error returned by
// LevelInfo.Validate if the designated constraints aren't met.
type LevelInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LevelInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LevelInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LevelInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LevelInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LevelInfoValidationError) ErrorName() string { return "LevelInfoValidationError" }

// Error satisfies the builtin error interface
func (e LevelInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLevelInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LevelInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LevelInfoValidationError{}

// Validate checks the field values on UserBaseInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserBaseInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserBaseInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserBaseInfoMultiError, or
// nil if none found.
func (m *UserBaseInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserBaseInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Nickname

	// no validation rules for Avatar

	// no validation rules for Xb

	if all {
		switch v := interface{}(m.GetBirthday()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserBaseInfoValidationError{
					field:  "Birthday",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserBaseInfoValidationError{
					field:  "Birthday",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBirthday()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserBaseInfoValidationError{
				field:  "Birthday",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIpRegion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserBaseInfoValidationError{
					field:  "IpRegion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserBaseInfoValidationError{
					field:  "IpRegion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIpRegion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserBaseInfoValidationError{
				field:  "IpRegion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserBaseInfoMultiError(errors)
	}

	return nil
}

// UserBaseInfoMultiError is an error wrapping multiple validation errors
// returned by UserBaseInfo.ValidateAll() if the designated constraints aren't met.
type UserBaseInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserBaseInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserBaseInfoMultiError) AllErrors() []error { return m }

// UserBaseInfoValidationError is the validation error returned by
// UserBaseInfo.Validate if the designated constraints aren't met.
type UserBaseInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserBaseInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserBaseInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserBaseInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserBaseInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserBaseInfoValidationError) ErrorName() string { return "UserBaseInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserBaseInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserBaseInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserBaseInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserBaseInfoValidationError{}

// Validate checks the field values on LoginReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginReqMultiError, or nil
// if none found.
func (m *LoginReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Password

	if len(errors) > 0 {
		return LoginReqMultiError(errors)
	}

	return nil
}

// LoginReqMultiError is an error wrapping multiple validation errors returned
// by LoginReq.ValidateAll() if the designated constraints aren't met.
type LoginReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginReqMultiError) AllErrors() []error { return m }

// LoginReqValidationError is the validation error returned by
// LoginReq.Validate if the designated constraints aren't met.
type LoginReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginReqValidationError) ErrorName() string { return "LoginReqValidationError" }

// Error satisfies the builtin error interface
func (e LoginReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginReqValidationError{}

// Validate checks the field values on LoginResp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginRespMultiError, or nil
// if none found.
func (m *LoginResp) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsNewUser

	// no validation rules for Token

	if len(errors) > 0 {
		return LoginRespMultiError(errors)
	}

	return nil
}

// LoginRespMultiError is an error wrapping multiple validation errors returned
// by LoginResp.ValidateAll() if the designated constraints aren't met.
type LoginRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginRespMultiError) AllErrors() []error { return m }

// LoginRespValidationError is the validation error returned by
// LoginResp.Validate if the designated constraints aren't met.
type LoginRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginRespValidationError) ErrorName() string { return "LoginRespValidationError" }

// Error satisfies the builtin error interface
func (e LoginRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginRespValidationError{}

// Validate checks the field values on ConfirmRegisterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfirmRegisterReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfirmRegisterReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfirmRegisterReqMultiError, or nil if none found.
func (m *ConfirmRegisterReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfirmRegisterReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfirmRegisterReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfirmRegisterReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfirmRegisterReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Password

	if len(errors) > 0 {
		return ConfirmRegisterReqMultiError(errors)
	}

	return nil
}

// ConfirmRegisterReqMultiError is an error wrapping multiple validation errors
// returned by ConfirmRegisterReq.ValidateAll() if the designated constraints
// aren't met.
type ConfirmRegisterReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfirmRegisterReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfirmRegisterReqMultiError) AllErrors() []error { return m }

// ConfirmRegisterReqValidationError is the validation error returned by
// ConfirmRegisterReq.Validate if the designated constraints aren't met.
type ConfirmRegisterReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfirmRegisterReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfirmRegisterReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfirmRegisterReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfirmRegisterReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfirmRegisterReqValidationError) ErrorName() string {
	return "ConfirmRegisterReqValidationError"
}

// Error satisfies the builtin error interface
func (e ConfirmRegisterReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfirmRegisterReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfirmRegisterReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfirmRegisterReqValidationError{}

// Validate checks the field values on ConfirmRegisterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfirmRegisterResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfirmRegisterResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfirmRegisterRespMultiError, or nil if none found.
func (m *ConfirmRegisterResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfirmRegisterResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfirmRegisterRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfirmRegisterRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfirmRegisterRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Token

	if len(errors) > 0 {
		return ConfirmRegisterRespMultiError(errors)
	}

	return nil
}

// ConfirmRegisterRespMultiError is an error wrapping multiple validation
// errors returned by ConfirmRegisterResp.ValidateAll() if the designated
// constraints aren't met.
type ConfirmRegisterRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfirmRegisterRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfirmRegisterRespMultiError) AllErrors() []error { return m }

// ConfirmRegisterRespValidationError is the validation error returned by
// ConfirmRegisterResp.Validate if the designated constraints aren't met.
type ConfirmRegisterRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfirmRegisterRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfirmRegisterRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfirmRegisterRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfirmRegisterRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfirmRegisterRespValidationError) ErrorName() string {
	return "ConfirmRegisterRespValidationError"
}

// Error satisfies the builtin error interface
func (e ConfirmRegisterRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfirmRegisterResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfirmRegisterRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfirmRegisterRespValidationError{}

// Validate checks the field values on MapUserByIdsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MapUserByIdsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapUserByIdsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MapUserByIdsReqMultiError, or nil if none found.
func (m *MapUserByIdsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MapUserByIdsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MapUserByIdsReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MapUserByIdsReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MapUserByIdsReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MapUserByIdsReqMultiError(errors)
	}

	return nil
}

// MapUserByIdsReqMultiError is an error wrapping multiple validation errors
// returned by MapUserByIdsReq.ValidateAll() if the designated constraints
// aren't met.
type MapUserByIdsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapUserByIdsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapUserByIdsReqMultiError) AllErrors() []error { return m }

// MapUserByIdsReqValidationError is the validation error returned by
// MapUserByIdsReq.Validate if the designated constraints aren't met.
type MapUserByIdsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapUserByIdsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapUserByIdsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapUserByIdsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapUserByIdsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapUserByIdsReqValidationError) ErrorName() string { return "MapUserByIdsReqValidationError" }

// Error satisfies the builtin error interface
func (e MapUserByIdsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapUserByIdsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapUserByIdsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapUserByIdsReqValidationError{}

// Validate checks the field values on MapUserByIdsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MapUserByIdsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapUserByIdsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MapUserByIdsRespMultiError, or nil if none found.
func (m *MapUserByIdsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *MapUserByIdsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MapUserByIdsRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MapUserByIdsRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MapUserByIdsRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Users

	if len(errors) > 0 {
		return MapUserByIdsRespMultiError(errors)
	}

	return nil
}

// MapUserByIdsRespMultiError is an error wrapping multiple validation errors
// returned by MapUserByIdsResp.ValidateAll() if the designated constraints
// aren't met.
type MapUserByIdsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapUserByIdsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapUserByIdsRespMultiError) AllErrors() []error { return m }

// MapUserByIdsRespValidationError is the validation error returned by
// MapUserByIdsResp.Validate if the designated constraints aren't met.
type MapUserByIdsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapUserByIdsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapUserByIdsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapUserByIdsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapUserByIdsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapUserByIdsRespValidationError) ErrorName() string { return "MapUserByIdsRespValidationError" }

// Error satisfies the builtin error interface
func (e MapUserByIdsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapUserByIdsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapUserByIdsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapUserByIdsRespValidationError{}

// Validate checks the field values on BatchGetUserBaseInfoReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchGetUserBaseInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchGetUserBaseInfoReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchGetUserBaseInfoReqMultiError, or nil if none found.
func (m *BatchGetUserBaseInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchGetUserBaseInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchGetUserBaseInfoReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchGetUserBaseInfoReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchGetUserBaseInfoReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BatchGetUserBaseInfoReqMultiError(errors)
	}

	return nil
}

// BatchGetUserBaseInfoReqMultiError is an error wrapping multiple validation
// errors returned by BatchGetUserBaseInfoReq.ValidateAll() if the designated
// constraints aren't met.
type BatchGetUserBaseInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetUserBaseInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetUserBaseInfoReqMultiError) AllErrors() []error { return m }

// BatchGetUserBaseInfoReqValidationError is the validation error returned by
// BatchGetUserBaseInfoReq.Validate if the designated constraints aren't met.
type BatchGetUserBaseInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetUserBaseInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetUserBaseInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetUserBaseInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetUserBaseInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetUserBaseInfoReqValidationError) ErrorName() string {
	return "BatchGetUserBaseInfoReqValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetUserBaseInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetUserBaseInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetUserBaseInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetUserBaseInfoReqValidationError{}

// Validate checks the field values on BatchGetUserBaseInfoResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchGetUserBaseInfoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchGetUserBaseInfoResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchGetUserBaseInfoRespMultiError, or nil if none found.
func (m *BatchGetUserBaseInfoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchGetUserBaseInfoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchGetUserBaseInfoRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchGetUserBaseInfoRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchGetUserBaseInfoRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetUserBaseInfos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchGetUserBaseInfoRespValidationError{
						field:  fmt.Sprintf("UserBaseInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchGetUserBaseInfoRespValidationError{
						field:  fmt.Sprintf("UserBaseInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchGetUserBaseInfoRespValidationError{
					field:  fmt.Sprintf("UserBaseInfos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatchGetUserBaseInfoRespMultiError(errors)
	}

	return nil
}

// BatchGetUserBaseInfoRespMultiError is an error wrapping multiple validation
// errors returned by BatchGetUserBaseInfoResp.ValidateAll() if the designated
// constraints aren't met.
type BatchGetUserBaseInfoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetUserBaseInfoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetUserBaseInfoRespMultiError) AllErrors() []error { return m }

// BatchGetUserBaseInfoRespValidationError is the validation error returned by
// BatchGetUserBaseInfoResp.Validate if the designated constraints aren't met.
type BatchGetUserBaseInfoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetUserBaseInfoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetUserBaseInfoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetUserBaseInfoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetUserBaseInfoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetUserBaseInfoRespValidationError) ErrorName() string {
	return "BatchGetUserBaseInfoRespValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetUserBaseInfoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetUserBaseInfoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetUserBaseInfoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetUserBaseInfoRespValidationError{}

// Validate checks the field values on SearchUsersByKeywordReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchUsersByKeywordReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchUsersByKeywordReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchUsersByKeywordReqMultiError, or nil if none found.
func (m *SearchUsersByKeywordReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchUsersByKeywordReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchUsersByKeywordReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchUsersByKeywordReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchUsersByKeywordReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Keyword

	if len(errors) > 0 {
		return SearchUsersByKeywordReqMultiError(errors)
	}

	return nil
}

// SearchUsersByKeywordReqMultiError is an error wrapping multiple validation
// errors returned by SearchUsersByKeywordReq.ValidateAll() if the designated
// constraints aren't met.
type SearchUsersByKeywordReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchUsersByKeywordReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchUsersByKeywordReqMultiError) AllErrors() []error { return m }

// SearchUsersByKeywordReqValidationError is the validation error returned by
// SearchUsersByKeywordReq.Validate if the designated constraints aren't met.
type SearchUsersByKeywordReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchUsersByKeywordReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchUsersByKeywordReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchUsersByKeywordReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchUsersByKeywordReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchUsersByKeywordReqValidationError) ErrorName() string {
	return "SearchUsersByKeywordReqValidationError"
}

// Error satisfies the builtin error interface
func (e SearchUsersByKeywordReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchUsersByKeywordReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchUsersByKeywordReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchUsersByKeywordReqValidationError{}

// Validate checks the field values on SearchUsersByKeywordResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchUsersByKeywordResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchUsersByKeywordResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchUsersByKeywordRespMultiError, or nil if none found.
func (m *SearchUsersByKeywordResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchUsersByKeywordResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchUsersByKeywordRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchUsersByKeywordRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchUsersByKeywordRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SearchUsersByKeywordRespValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SearchUsersByKeywordRespValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SearchUsersByKeywordRespValidationError{
					field:  fmt.Sprintf("Users[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SearchUsersByKeywordRespMultiError(errors)
	}

	return nil
}

// SearchUsersByKeywordRespMultiError is an error wrapping multiple validation
// errors returned by SearchUsersByKeywordResp.ValidateAll() if the designated
// constraints aren't met.
type SearchUsersByKeywordRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchUsersByKeywordRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchUsersByKeywordRespMultiError) AllErrors() []error { return m }

// SearchUsersByKeywordRespValidationError is the validation error returned by
// SearchUsersByKeywordResp.Validate if the designated constraints aren't met.
type SearchUsersByKeywordRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchUsersByKeywordRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchUsersByKeywordRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchUsersByKeywordRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchUsersByKeywordRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchUsersByKeywordRespValidationError) ErrorName() string {
	return "SearchUsersByKeywordRespValidationError"
}

// Error satisfies the builtin error interface
func (e SearchUsersByKeywordRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchUsersByKeywordResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchUsersByKeywordRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchUsersByKeywordRespValidationError{}

// Validate checks the field values on GetUserHomeReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetUserHomeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserHomeReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetUserHomeReqMultiError,
// or nil if none found.
func (m *GetUserHomeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserHomeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserHomeReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserHomeReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserHomeReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if len(errors) > 0 {
		return GetUserHomeReqMultiError(errors)
	}

	return nil
}

// GetUserHomeReqMultiError is an error wrapping multiple validation errors
// returned by GetUserHomeReq.ValidateAll() if the designated constraints
// aren't met.
type GetUserHomeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserHomeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserHomeReqMultiError) AllErrors() []error { return m }

// GetUserHomeReqValidationError is the validation error returned by
// GetUserHomeReq.Validate if the designated constraints aren't met.
type GetUserHomeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserHomeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserHomeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserHomeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserHomeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserHomeReqValidationError) ErrorName() string { return "GetUserHomeReqValidationError" }

// Error satisfies the builtin error interface
func (e GetUserHomeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserHomeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserHomeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserHomeReqValidationError{}

// Validate checks the field values on GetUserHomeResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetUserHomeResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserHomeResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserHomeRespMultiError, or nil if none found.
func (m *GetUserHomeResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserHomeResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserHomeRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserHomeRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserHomeRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for Nickname

	// no validation rules for Avatar

	// no validation rules for Xb

	if all {
		switch v := interface{}(m.GetBirthday()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserHomeRespValidationError{
					field:  "Birthday",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserHomeRespValidationError{
					field:  "Birthday",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBirthday()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserHomeRespValidationError{
				field:  "Birthday",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIpRegion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserHomeRespValidationError{
					field:  "IpRegion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserHomeRespValidationError{
					field:  "IpRegion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIpRegion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserHomeRespValidationError{
				field:  "IpRegion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Signature

	if all {
		switch v := interface{}(m.GetLevelInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserHomeRespValidationError{
					field:  "LevelInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserHomeRespValidationError{
					field:  "LevelInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLevelInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserHomeRespValidationError{
				field:  "LevelInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetUserHomeRespMultiError(errors)
	}

	return nil
}

// GetUserHomeRespMultiError is an error wrapping multiple validation errors
// returned by GetUserHomeResp.ValidateAll() if the designated constraints
// aren't met.
type GetUserHomeRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserHomeRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserHomeRespMultiError) AllErrors() []error { return m }

// GetUserHomeRespValidationError is the validation error returned by
// GetUserHomeResp.Validate if the designated constraints aren't met.
type GetUserHomeRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserHomeRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserHomeRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserHomeRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserHomeRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserHomeRespValidationError) ErrorName() string { return "GetUserHomeRespValidationError" }

// Error satisfies the builtin error interface
func (e GetUserHomeRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserHomeResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserHomeRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserHomeRespValidationError{}

// Validate checks the field values on GetUserSettingsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserSettingsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserSettingsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserSettingsReqMultiError, or nil if none found.
func (m *GetUserSettingsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserSettingsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserSettingsReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserSettingsReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserSettingsReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetUserSettingsReqMultiError(errors)
	}

	return nil
}

// GetUserSettingsReqMultiError is an error wrapping multiple validation errors
// returned by GetUserSettingsReq.ValidateAll() if the designated constraints
// aren't met.
type GetUserSettingsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserSettingsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserSettingsReqMultiError) AllErrors() []error { return m }

// GetUserSettingsReqValidationError is the validation error returned by
// GetUserSettingsReq.Validate if the designated constraints aren't met.
type GetUserSettingsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserSettingsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserSettingsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserSettingsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserSettingsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserSettingsReqValidationError) ErrorName() string {
	return "GetUserSettingsReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserSettingsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserSettingsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserSettingsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserSettingsReqValidationError{}

// Validate checks the field values on UserSetting with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserSetting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserSetting with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserSettingMultiError, or
// nil if none found.
func (m *UserSetting) ValidateAll() error {
	return m.validate(true)
}

func (m *UserSetting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Key

	// no validation rules for Value

	if len(errors) > 0 {
		return UserSettingMultiError(errors)
	}

	return nil
}

// UserSettingMultiError is an error wrapping multiple validation errors
// returned by UserSetting.ValidateAll() if the designated constraints aren't met.
type UserSettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserSettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserSettingMultiError) AllErrors() []error { return m }

// UserSettingValidationError is the validation error returned by
// UserSetting.Validate if the designated constraints aren't met.
type UserSettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSettingValidationError) ErrorName() string { return "UserSettingValidationError" }

// Error satisfies the builtin error interface
func (e UserSettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSettingValidationError{}

// Validate checks the field values on GetUserSettingsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserSettingsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserSettingsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserSettingsRespMultiError, or nil if none found.
func (m *GetUserSettingsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserSettingsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserSettingsRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserSettingsRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserSettingsRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]int32, len(m.GetSettings()))
		i := 0
		for key := range m.GetSettings() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSettings()[key]
			_ = val

			// no validation rules for Settings[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetUserSettingsRespValidationError{
							field:  fmt.Sprintf("Settings[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetUserSettingsRespValidationError{
							field:  fmt.Sprintf("Settings[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetUserSettingsRespValidationError{
						field:  fmt.Sprintf("Settings[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return GetUserSettingsRespMultiError(errors)
	}

	return nil
}

// GetUserSettingsRespMultiError is an error wrapping multiple validation
// errors returned by GetUserSettingsResp.ValidateAll() if the designated
// constraints aren't met.
type GetUserSettingsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserSettingsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserSettingsRespMultiError) AllErrors() []error { return m }

// GetUserSettingsRespValidationError is the validation error returned by
// GetUserSettingsResp.Validate if the designated constraints aren't met.
type GetUserSettingsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserSettingsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserSettingsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserSettingsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserSettingsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserSettingsRespValidationError) ErrorName() string {
	return "GetUserSettingsRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserSettingsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserSettingsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserSettingsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserSettingsRespValidationError{}

// Validate checks the field values on SetUserSettingsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetUserSettingsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetUserSettingsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetUserSettingsReqMultiError, or nil if none found.
func (m *SetUserSettingsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SetUserSettingsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetUserSettingsReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetUserSettingsReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetUserSettingsReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSettings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetUserSettingsReqValidationError{
						field:  fmt.Sprintf("Settings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetUserSettingsReqValidationError{
						field:  fmt.Sprintf("Settings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetUserSettingsReqValidationError{
					field:  fmt.Sprintf("Settings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SetUserSettingsReqMultiError(errors)
	}

	return nil
}

// SetUserSettingsReqMultiError is an error wrapping multiple validation errors
// returned by SetUserSettingsReq.ValidateAll() if the designated constraints
// aren't met.
type SetUserSettingsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetUserSettingsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetUserSettingsReqMultiError) AllErrors() []error { return m }

// SetUserSettingsReqValidationError is the validation error returned by
// SetUserSettingsReq.Validate if the designated constraints aren't met.
type SetUserSettingsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetUserSettingsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetUserSettingsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetUserSettingsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetUserSettingsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetUserSettingsReqValidationError) ErrorName() string {
	return "SetUserSettingsReqValidationError"
}

// Error satisfies the builtin error interface
func (e SetUserSettingsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetUserSettingsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetUserSettingsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetUserSettingsReqValidationError{}

// Validate checks the field values on SetUserSettingsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetUserSettingsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetUserSettingsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetUserSettingsRespMultiError, or nil if none found.
func (m *SetUserSettingsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *SetUserSettingsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetUserSettingsRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetUserSettingsRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetUserSettingsRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SetUserSettingsRespMultiError(errors)
	}

	return nil
}

// SetUserSettingsRespMultiError is an error wrapping multiple validation
// errors returned by SetUserSettingsResp.ValidateAll() if the designated
// constraints aren't met.
type SetUserSettingsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetUserSettingsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetUserSettingsRespMultiError) AllErrors() []error { return m }

// SetUserSettingsRespValidationError is the validation error returned by
// SetUserSettingsResp.Validate if the designated constraints aren't met.
type SetUserSettingsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetUserSettingsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetUserSettingsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetUserSettingsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetUserSettingsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetUserSettingsRespValidationError) ErrorName() string {
	return "SetUserSettingsRespValidationError"
}

// Error satisfies the builtin error interface
func (e SetUserSettingsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetUserSettingsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetUserSettingsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetUserSettingsRespValidationError{}

// Validate checks the field values on BatchGetUserAllDevicesReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchGetUserAllDevicesReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchGetUserAllDevicesReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchGetUserAllDevicesReqMultiError, or nil if none found.
func (m *BatchGetUserAllDevicesReq) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchGetUserAllDevicesReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchGetUserAllDevicesReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchGetUserAllDevicesReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchGetUserAllDevicesReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BatchGetUserAllDevicesReqMultiError(errors)
	}

	return nil
}

// BatchGetUserAllDevicesReqMultiError is an error wrapping multiple validation
// errors returned by BatchGetUserAllDevicesReq.ValidateAll() if the
// designated constraints aren't met.
type BatchGetUserAllDevicesReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetUserAllDevicesReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetUserAllDevicesReqMultiError) AllErrors() []error { return m }

// BatchGetUserAllDevicesReqValidationError is the validation error returned by
// BatchGetUserAllDevicesReq.Validate if the designated constraints aren't met.
type BatchGetUserAllDevicesReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetUserAllDevicesReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetUserAllDevicesReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetUserAllDevicesReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetUserAllDevicesReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetUserAllDevicesReqValidationError) ErrorName() string {
	return "BatchGetUserAllDevicesReqValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetUserAllDevicesReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetUserAllDevicesReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetUserAllDevicesReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetUserAllDevicesReqValidationError{}

// Validate checks the field values on BatchGetUserAllDevicesResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchGetUserAllDevicesResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchGetUserAllDevicesResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchGetUserAllDevicesRespMultiError, or nil if none found.
func (m *BatchGetUserAllDevicesResp) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchGetUserAllDevicesResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchGetUserAllDevicesRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchGetUserAllDevicesRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchGetUserAllDevicesRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAllDevices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchGetUserAllDevicesRespValidationError{
						field:  fmt.Sprintf("AllDevices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchGetUserAllDevicesRespValidationError{
						field:  fmt.Sprintf("AllDevices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchGetUserAllDevicesRespValidationError{
					field:  fmt.Sprintf("AllDevices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatchGetUserAllDevicesRespMultiError(errors)
	}

	return nil
}

// BatchGetUserAllDevicesRespMultiError is an error wrapping multiple
// validation errors returned by BatchGetUserAllDevicesResp.ValidateAll() if
// the designated constraints aren't met.
type BatchGetUserAllDevicesRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetUserAllDevicesRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetUserAllDevicesRespMultiError) AllErrors() []error { return m }

// BatchGetUserAllDevicesRespValidationError is the validation error returned
// by BatchGetUserAllDevicesResp.Validate if the designated constraints aren't met.
type BatchGetUserAllDevicesRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetUserAllDevicesRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetUserAllDevicesRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetUserAllDevicesRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetUserAllDevicesRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetUserAllDevicesRespValidationError) ErrorName() string {
	return "BatchGetUserAllDevicesRespValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetUserAllDevicesRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetUserAllDevicesResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetUserAllDevicesRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetUserAllDevicesRespValidationError{}

// Validate checks the field values on UpdateUserInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserInfoReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserInfoReqMultiError, or nil if none found.
func (m *UpdateUserInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonReq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserInfoReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserInfoReqValidationError{
					field:  "CommonReq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonReq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserInfoReqValidationError{
				field:  "CommonReq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Nickname != nil {
		// no validation rules for Nickname
	}

	if m.Avatar != nil {
		// no validation rules for Avatar
	}

	if m.Signature != nil {
		// no validation rules for Signature
	}

	if len(errors) > 0 {
		return UpdateUserInfoReqMultiError(errors)
	}

	return nil
}

// UpdateUserInfoReqMultiError is an error wrapping multiple validation errors
// returned by UpdateUserInfoReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserInfoReqMultiError) AllErrors() []error { return m }

// UpdateUserInfoReqValidationError is the validation error returned by
// UpdateUserInfoReq.Validate if the designated constraints aren't met.
type UpdateUserInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserInfoReqValidationError) ErrorName() string {
	return "UpdateUserInfoReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserInfoReqValidationError{}

// Validate checks the field values on UpdateUserInfoResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateUserInfoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateUserInfoResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateUserInfoRespMultiError, or nil if none found.
func (m *UpdateUserInfoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateUserInfoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommonResp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateUserInfoRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateUserInfoRespValidationError{
					field:  "CommonResp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommonResp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateUserInfoRespValidationError{
				field:  "CommonResp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateUserInfoRespMultiError(errors)
	}

	return nil
}

// UpdateUserInfoRespMultiError is an error wrapping multiple validation errors
// returned by UpdateUserInfoResp.ValidateAll() if the designated constraints
// aren't met.
type UpdateUserInfoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUserInfoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUserInfoRespMultiError) AllErrors() []error { return m }

// UpdateUserInfoRespValidationError is the validation error returned by
// UpdateUserInfoResp.Validate if the designated constraints aren't met.
type UpdateUserInfoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserInfoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserInfoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserInfoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserInfoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserInfoRespValidationError) ErrorName() string {
	return "UpdateUserInfoRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserInfoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserInfoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserInfoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserInfoRespValidationError{}

// Validate checks the field values on BatchGetUserAllDevicesResp_AllDevices
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *BatchGetUserAllDevicesResp_AllDevices) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchGetUserAllDevicesResp_AllDevices
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// BatchGetUserAllDevicesResp_AllDevicesMultiError, or nil if none found.
func (m *BatchGetUserAllDevicesResp_AllDevices) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchGetUserAllDevicesResp_AllDevices) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if len(errors) > 0 {
		return BatchGetUserAllDevicesResp_AllDevicesMultiError(errors)
	}

	return nil
}

// BatchGetUserAllDevicesResp_AllDevicesMultiError is an error wrapping
// multiple validation errors returned by
// BatchGetUserAllDevicesResp_AllDevices.ValidateAll() if the designated
// constraints aren't met.
type BatchGetUserAllDevicesResp_AllDevicesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetUserAllDevicesResp_AllDevicesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetUserAllDevicesResp_AllDevicesMultiError) AllErrors() []error { return m }

// BatchGetUserAllDevicesResp_AllDevicesValidationError is the validation error
// returned by BatchGetUserAllDevicesResp_AllDevices.Validate if the
// designated constraints aren't met.
type BatchGetUserAllDevicesResp_AllDevicesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetUserAllDevicesResp_AllDevicesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetUserAllDevicesResp_AllDevicesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetUserAllDevicesResp_AllDevicesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetUserAllDevicesResp_AllDevicesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetUserAllDevicesResp_AllDevicesValidationError) ErrorName() string {
	return "BatchGetUserAllDevicesResp_AllDevicesValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetUserAllDevicesResp_AllDevicesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetUserAllDevicesResp_AllDevices.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetUserAllDevicesResp_AllDevicesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetUserAllDevicesResp_AllDevicesValidationError{}
